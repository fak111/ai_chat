---
title: A宝技术领导力手册
version: v1.0
created: 2026-02-07
updated: 2026-02-07
author: zfc
---

# A宝技术领导力手册

> 写给关注结果、但需要理解机器如何运转的决策者。
>
> 你不需要会修发动机，但你需要知道：油门踩下去之后，哪些零件在转动，为什么这样设计，以及哪里可能出问题。

---

## 目录

- [第一章 全局视角：系统是怎么运转的](#第一章-全局视角系统是怎么运转的)
- [第二章 安全门卫：用户认证系统](#第二章-安全门卫用户认证系统)
- [第三章 组织架构：群聊系统](#第三章-组织架构群聊系统)
- [第四章 通信网络：消息系统](#第四章-通信网络消息系统)
- [第五章 AI 大脑：核心智能服务（重点）](#第五章-ai-大脑核心智能服务重点)
- [第六章 前端门面：用户看到的一切](#第六章-前端门面用户看到的一切)
- [第七章 技术决策备忘录](#第七章-技术决策备忘录)
- [第八章 风险地图：哪里可能出问题](#第八章-风险地图哪里可能出问题)

---

## 第一章 全局视角：系统是怎么运转的

### 1.1 一句话概括

A宝是一个让熟人群聊中能 @AI 对话的应用。技术上，它是一个 **Flutter 前端 + Spring Boot 后端 + PostgreSQL 数据库 + DeepSeek AI** 的四层架构。

### 1.2 如果 A宝是一家公司

把整个系统想象成一家公司的办公楼：

```
┌─────────────────────────────────────────────────────┐
│                    用户的手机/浏览器                    │
│              （客户来到公司大厅）                        │
└───────────────────────┬─────────────────────────────┘
                        │
            ┌───────────▼───────────┐
            │    Flutter 前端 App    │  ← 大厅前台：接待客户、展示信息
            │  （Provider 状态管理）  │     知道怎么引导客户，但不做决策
            └───────────┬───────────┘
                        │
         ┌──────────────┼──────────────┐
         │ HTTP REST    │              │ WebSocket
         │ （写信沟通）   │              │ （实时对讲机）
         │              │              │
┌────────▼────────┬─────▼──────┬───────▼────────┐
│  Auth 认证模块   │ 群聊/消息   │  WebSocket     │
│ （保安部）       │ （业务部）   │  （通信部）     │  ← Spring Boot 后端
├─────────────────┴────────────┴────────────────┤      公司的各个部门
│                  AI 服务                       │
│              （外聘顾问部）                      │  ← 调用 DeepSeek API
├───────────────────────────────────────────────┤
│               数据库 PostgreSQL                │  ← 档案室：所有数据的归宿
└───────────────────────────────────────────────┘
```

### 1.3 一次完整的用户操作，发生了什么？

以"用户发送 @AI 你好"为例，完整链路：

```
用户在手机上打字 "@AI 你好" → 点击发送
      │
      ▼
[1] Flutter 前端把消息通过 HTTP POST 发给后端
      │
      ▼
[2] 后端 MessageService 收到消息：
    - 验证"你是这个群的成员吗？" ✓
    - 存入 PostgreSQL 数据库
    - 通过 WebSocket 广播给群内所有在线的人
    - 发布一个"有新消息"的内部事件
      │
      ▼
[3] AI 服务监听到事件，发现消息里有 @AI：
    - 去数据库查最近 30 分钟的聊天记录
    - 把聊天记录整理成 AI 能理解的格式
    - 调用 DeepSeek API："请根据上下文回复"
      │
      ▼
[4] DeepSeek 返回回复内容 → AI 服务把回复当消息存入数据库
    → 再通过 WebSocket 广播给群内所有人
      │
      ▼
[5] Flutter 前端收到 WebSocket 推送 → 页面自动显示 AI 回复
```

**关键认知**：用户发消息用的是 HTTP（像写信，有回执），收消息用的是 WebSocket（像对讲机，实时响铃）。这是两条不同的通道。

### 1.4 技术栈速查表

| 你关心的问题 | 答案 | 类比 |
|------------|------|------|
| 前端用什么框架？ | Flutter 3.x + Provider | 一套代码，iOS/Android/Web 三端通吃 |
| 后端用什么语言？ | Java 17 + Spring Boot 3.2 | 企业级标准，像 Java 世界的"万能框架" |
| 数据存在哪？ | PostgreSQL 15 | 最可靠的开源数据库，相当于数据界的"银行金库" |
| 用户密码安全吗？ | BCrypt 加密（10 轮） | 即使数据库泄露，密码也无法被还原 |
| 认证机制？ | JWT 双 Token | 短期通行证（2 小时）+ 长期会员卡（7 天） |
| 实时消息怎么做？ | WebSocket 原生协议 | 服务器和手机之间的"永久电话线" |
| AI 用的什么模型？ | DeepSeek Chat API | 国产大语言模型，性价比高 |
| 缓存方案？ | Caffeine 本地缓存 | 数据的"速记本"，不用每次都翻档案室 |

---

## 第二章 安全门卫：用户认证系统

### 2.1 这个部门做什么

认证系统是公司的**保安部**——决定谁能进门、谁不能进，进门后给你发工牌（Token），工牌过期了帮你换新的。

### 2.2 登录流程：你刷脸进公司

```
用户输入邮箱+密码
    │
    ▼
后端用 BCrypt 验证密码
（不是直接比对明文，而是用同样的加密方式处理一遍，比对加密结果）
    │
    ▼ 密码正确
发放两张"卡"：
┌──────────────────┐  ┌──────────────────┐
│  Access Token    │  │  Refresh Token   │
│  临时通行证       │  │  会员卡           │
│  有效期 2 小时    │  │  有效期 7 天      │
│  每次请求都要带   │  │  只在续期时使用    │
└──────────────────┘  └──────────────────┘
```

**为什么需要两张卡？**

想象你去健身房：门禁卡（Access Token）每天刷，丢了损失有限；会员卡（Refresh Token）锁在柜子里，只在门禁卡过期时拿出来换新的。这样即使有人偷到你的门禁卡，2 小时后就失效了。

### 2.3 Token 自动续期：用户无感知

```
前端发请求 → 后端说"你的通行证过期了"(401)
    │
    ▼
前端自动拿会员卡换一张新通行证（静默刷新）
    │
    ▼ 成功
用新通行证重新发送刚才的请求（用户完全无感知）
    │
    ▼ 失败（会员卡也过期了）
弹出"请重新登录"提示
```

这个机制的精妙之处：**用户永远不会在操作到一半时被踢出去**，除非连续 7 天没打开 App。

### 2.4 注册流程：邮箱验证的容错设计

```
用户提交注册信息
    │
    ├──→ 密码 BCrypt 加密后存入数据库 ✓
    │
    └──→ 尝试发送验证邮件（通过 Resend API）
              │
              ├──→ 发送成功 → 用户点击邮件中的链接完成验证
              │
              └──→ 发送失败 → 只记录日志，不阻断注册
                          （开发环境可直接改数据库手动验证）
```

**决策者视角**：邮件服务是第三方的（Resend），不可控。如果邮件发不出去就注册失败，等于把核心功能的命运交给了别人。所以设计成"先注册再验证"，邮件失败不影响注册本身。

### 2.5 保安部的关键人员

| 角色 | 文件 | 职责 |
|------|------|------|
| 保安队长 | `SecurityConfig.java` | 决定哪些门（API）需要刷卡，哪些门自由出入 |
| 工牌制作 | `JwtTokenProvider.java` | 生成和验证 JWT Token |
| 门口保安 | `JwtAuthenticationFilter.java` | 每个请求进来，检查工牌是否有效 |
| 前台接待 | `AuthController.java` | 处理注册、登录、刷新 Token 的请求 |
| 后台核实 | `AuthService.java` | 查数据库验证身份，管理 Token 生命周期 |

---

## 第三章 组织架构：群聊系统

### 3.1 这个部门做什么

群聊系统是公司的**组织人事部**——负责建立部门（群聊）、招人（加入群聊）、管理花名册（成员列表），以及给每个新部门配一个 AI 助理。

### 3.2 创建群聊：开一个新部门

```
用户说"我要建个群"
    │
    ▼
后端做三件事（在一个事务里，要么全成功，要么全回滚）：
    │
    ├─ [1] 创建群聊记录 + 生成 6 位邀请码（如 "A3X9K2"）
    │
    ├─ [2] 把创建者加为成员
    │
    └─ [3] 自动添加一个 AI 成员（user=null, isAi=true）
```

**邀请码为什么只有 6 位？** 6 位字母+数字 = 36^6 = 20 亿种组合。对于一个 MVP 产品来说绰绰有余。太长了不方便分享（想象在微信里发一串 32 位的码），太短了容易撞码。6 位是个平衡点。

### 3.3 AI 成员的特殊身份

每个群聊都自动有一个 AI 成员。这个成员比较特殊：

```
普通成员：
┌─────────────────┐
│ GroupMember      │
│ user = 张三      │ ← 关联了一个真实用户
│ isAi = false    │
└─────────────────┘

AI 成员：
┌─────────────────┐
│ GroupMember      │
│ user = null     │ ← 没有关联真实用户（它是虚拟的）
│ isAi = true     │
└─────────────────┘
```

**这个设计引发过 Bug**：代码里有很多地方会调用 `member.getUser().getId()`，AI 成员的 `user` 是 null，一调就崩。这是项目踩过的一个大坑（NPE 问题），后来加了 null 检查才修好。

### 3.4 数据模型：三张核心表的关系

```
┌──────────┐          ┌───────────────┐          ┌──────────┐
│  users   │─── 1:N ──│ group_members │── N:1 ───│  groups  │
│ (用户表)  │          │  (成员关系表)   │          │ (群聊表)  │
└──────────┘          └───────────────┘          └────┬─────┘
                                                      │ 1:N
                                                 ┌────▼─────┐
                                                 │ messages  │
                                                 │ (消息表)   │
                                                 └──────────┘
```

**为什么需要中间表 `group_members`？** 因为用户和群聊是多对多关系——一个用户可以加入多个群，一个群可以有多个用户。中间表就是这个多对多关系的"桥梁"。

---

## 第四章 通信网络：消息系统

### 4.1 这个部门做什么

消息系统是公司的**通信部**——负责收发信件（HTTP 消息）和维护对讲机网络（WebSocket），确保每条消息都能送达。

### 4.2 两条通信管道

A宝的消息系统用了**两条管道**，这是理解整个通信架构的关键：

```
┌─────────────────────────────────────────────┐
│            HTTP REST（信件通道）               │
│                                             │
│  特点：可靠，有回执，但不实时                    │
│  用途：发送消息、查询历史消息                    │
│  类比：寄挂号信，签收后你知道对方收到了          │
└─────────────────────────────────────────────┘

┌─────────────────────────────────────────────┐
│           WebSocket（对讲机通道）              │
│                                             │
│  特点：实时，但不保证100%送达                   │
│  用途：接收推送消息（包括别人的消息和AI回复）     │
│  类比：对讲机，说完就完了，对方可能没听到         │
└─────────────────────────────────────────────┘
```

**为什么不全用 WebSocket？** 因为 WebSocket 是"说完就完了"的模式。你发一条消息出去，如果网络抖了一下，你不知道对方收没收到。HTTP 会给你一个明确的回复（200 OK 或者错误码），你可以提示用户"发送失败，请重试"。

**为什么不全用 HTTP？** 因为 HTTP 是"你问我才答"的模式。如果只用 HTTP，你要不停地问服务器"有新消息吗？有新消息吗？"（轮询），浪费资源且不实时。WebSocket 是"有消息我主动告诉你"。

### 4.3 消息的完整生命周期

```
                          发送方                                        接收方
                            │                                            │
用户点击发送 ──────────────────▶ HTTP POST /api/messages ──────────────────▶ 后端收到
                            │                                            │
                            │  后端做四件事：                               │
                            │  [1] 验证身份（你是群成员吗？）                │
                            │  [2] 存入数据库                              │
                            │  [3] WebSocket 广播给所有在线成员  ──────────▶ 实时收到！
                            │  [4] 发布事件（触发 AI 判断）                  │
                            │                                            │
HTTP 返回消息对象 ◀────────── 后端回复 200 OK                              │
（前端立即显示自己发的消息）                                                 │
                                                                         │
                            如果 WebSocket 断了怎么办？                     │
                            ─────────────────────────                     │
                            前端每 5 秒用 HTTP 轮询一次  ──────────────────▶ 兜底收到
                            （像定时检查信箱）
```

### 4.4 消息去重：同一条消息不会显示两遍

因为有两条管道（WebSocket 推送 + HTTP 轮询兜底），同一条消息可能从两个渠道到达。前端用消息 ID 做去重：

```
新消息到达 → 检查 ID 是否已存在
    │
    ├─ 已存在 → 丢弃（不重复显示）
    │
    └─ 不存在 → 插入消息列表 → 更新 UI
```

### 4.5 WebSocket 的生命周期管理

WebSocket 不是"连上就完事了"，它需要持续维护：

```
[建立连接]
客户端带着 Token 请求 ws://host/ws?token=xxx
    │
    ▼
服务端验证 Token → 记录"用户A在线" → 连接建立
    │
    ▼
[保持心跳]
每 30 秒：客户端发 PING → 服务端回 PONG
（如果服务端超时没收到 PING，认为客户端断线）
    │
    ▼
[断线重连]
网络抖动 → 连接断开 → 客户端自动重连
等待时间：1秒 → 3秒 → 5秒 → 7秒...（指数退避，不要疯狂重试）
    │
    ▼
[重连后恢复]
重新加入之前订阅的群聊频道
（不会丢失群聊订阅状态）
```

**决策者视角**：WebSocket 连接本身是脆弱的（网络切换、手机锁屏都会断），所以设计了三重保障——心跳检测、自动重连、HTTP 轮询兜底。这就是为什么即使网络不稳定，消息也基本不会丢。

### 4.6 通信部的关键人员

| 后端角色 | 文件 | 职责 |
|---------|------|------|
| 信件收发室 | `MessageController.java` | 处理 HTTP 消息请求 |
| 信件处理中心 | `MessageService.java` | 消息业务逻辑：验证、存储、广播、触发 AI |
| 对讲机总台 | `WebSocketHandler.java` | 处理 WebSocket 消息路由 |
| 对讲机管理员 | `WebSocketSessionManager.java` | 管理在线用户和群聊频道 |
| 门口验证 | `JwtHandshakeInterceptor.java` | WebSocket 连接时验证 Token |

| 前端角色 | 文件 | 职责 |
|---------|------|------|
| HTTP 客户端 | `api_service.dart` | 发送 HTTP 请求，自动带 Token，自动重试 401 |
| WebSocket 客户端 | `websocket_service.dart` | 管理连接、心跳、重连、消息分发 |
| 消息调度中心 | `chat_provider.dart` | 整合两个通道的消息，去重，通知 UI 刷新 |

---

## 第五章 AI 大脑：核心智能服务（重点）

> 这是 A宝的灵魂模块。如果前面的章节是"躯体如何运转"，这一章就是"大脑如何思考"。

### 5.1 这个部门做什么

AI 服务是公司的**外聘顾问部**——它不常驻公司（不在本地运行），而是通过电话（API 调用）为群聊提供智能回复。它的工作流程是：监听会议纪要（消息事件）→ 判断是否需要发言 → 翻阅最近的聊天记录做功课 → 打电话给外部顾问（DeepSeek）→ 把顾问的回答转述给大家。

### 5.2 AI 什么时候会说话？

AI 不是每条消息都回复。它有明确的触发条件：

```
新消息到达
    │
    ├─ 条件 1：消息内容包含 "@AI"（不区分大小写）
    │          例如："@AI 今天天气怎么样"  → 触发
    │          例如："@ai 帮我翻译一下"    → 触发
    │          例如："发个 email 给张三"   → 不触发（email 包含 ai 但不是 @AI）
    │
    ├─ 条件 2：回复的是一条 AI 消息
    │          例如：用户引用了 AI 之前的回复，追问 → 触发
    │
    └─ 都不满足 → AI 保持沉默
```

**为什么用正则 `@[Aa][Ii]\b` 而不是简单的字符串包含？**

`\b` 是"单词边界"的意思。如果只用 `contains("@AI")`，那"发个 EMAIL" 也会误触发。加了 `\b` 后，`@AI` 后面必须是空格、标点或句尾，避免误判。

### 5.3 事件驱动：AI 为什么不会拖慢你发消息？

这里有一个关键的架构设计——**异步事件驱动**：

```
用户发消息
    │
    ▼
MessageService.sendMessage()
    │
    ├──→ [同步] 存数据库 + WebSocket 广播   → 立即完成（毫秒级）
    │                                         用户马上看到自己发的消息
    │
    └──→ [异步] 发布 MessageSentEvent        → 扔到后台，主流程不等待
              │
              ▼
         MessageEventListener 收到事件
              │
              ▼ （在独立线程中运行）
         AIService.processMessage()          → 耗时 2-5 秒
              │
              ├─ 不需要 AI → 直接结束
              │
              └─ 需要 AI → 查上下文 → 调 API → 保存回复 → 广播
                                                          用户 2-5 秒后看到 AI 回复
```

**决策者视角**：如果 AI 处理是同步的（串行），用户发一条 @AI 消息后要等 5 秒才能看到自己发的消息。异步化后，用户发消息是瞬间的，AI 回复晚几秒到是自然的——就像群里有个真人在打字回复你，等一等很正常。

### 5.4 上下文构建：AI 的"功课"

AI 回复之前，要先做功课——了解最近群里在聊什么。这个过程叫**上下文构建**，是 AI 服务最核心的逻辑：

```
触发 AI 回复
    │
    ▼
[第一步] 从数据库查询"最近 30 分钟内、最多 50 条消息"
         │
         为什么是 30 分钟？
         → 太短（5分钟）：AI 缺少上下文，答非所问
         → 太长（24小时）：冷群积累大量无关消息，浪费 Token
         → 30 分钟是活跃对话的合理窗口
         │
         为什么最多 50 条？
         → DeepSeek API 有 Token 限制，50 条约 2000-3000 Token
         → 超过 50 条的对话，最早的消息对当前问题意义不大
    │
    ▼
[第二步] 提取群内活跃成员昵称
         → 去重（同一个人不重复列出）
         → 防注入（去掉换行符，截断到 20 字符）
         → 用途：告诉 AI "群里现在有谁"
    │
    ▼
[第三步] 构建 System Prompt（给 AI 下达人设指令）
         ┌───────────────────────────────────────────┐
         │ "你是 A宝，一个群聊 AI 助手。               │
         │                                           │
         │  群内活跃成员：张三、李四、王五              │
         │                                           │
         │  你的风格：友好、简洁、有趣                 │
         │  用口语化中文回复，不要过度使用 emoji         │
         │  回复控制在 1-3 句话                        │
         │                                           │
         │  规则：                                    │
         │  - 只回复 @AI 的消息，参考上下文理解语境     │
         │  - 如果问"群里有谁"，根据成员列表回答       │
         │  - 不要重复之前说过的内容"                   │
         └───────────────────────────────────────────┘
    │
    ▼
[第四步] 把历史消息转换成 AI 能理解的格式

    原始消息：                       转换后（OpenAI 格式）：

    张三(用户): "@AI 你好"      →    {role: "user",      content: "张三: 你好"}
    A宝(AI):   "你好张三！"     →    {role: "assistant",  content: "你好张三！"}
    李四(用户): "在聊什么呢"    →    {role: "user",      content: "李四: 在聊什么呢"}
    张三(用户): "@AI 给我讲个笑话" → {role: "user",      content: "张三: 给我讲个笑话"}

    注意：@AI 在发给 DeepSeek 之前会被移除（AI 不需要看到自己被 @）
```

### 5.5 DeepSeek API 调用：打电话给顾问

上下文构建完成后，打包发给 DeepSeek：

```
请求内容：
{
    "model": "deepseek-chat",
    "messages": [
        {"role": "system",    "content": "你是A宝...（人设）"},
        {"role": "user",      "content": "张三: 你好"},
        {"role": "assistant", "content": "你好张三！"},
        {"role": "user",      "content": "张三: 给我讲个笑话"}
    ],
    "max_tokens": 2048,        ← AI 回复最长 2048 个 Token（约 1000 字）
    "temperature": 0.7         ← 创造性程度，0=死板照搬，1=天马行空，0.7=比较自然
}

响应内容：
{
    "choices": [{
        "message": {
            "content": "好的！为什么程序员总是分不清万圣节和圣诞节？因为 Oct 31 = Dec 25！🎃"
        }
    }]
}
```

**temperature 参数**的直觉理解：
- `0.0` — 每次问同样的问题，给同样的答案（适合客服 FAQ）
- `0.7` — 有一定随机性，但不会太离谱（适合日常聊天）
- `1.0` — 非常有创意，但可能胡说八道（适合头脑风暴）

### 5.6 AI 回复后发生什么？

```
DeepSeek 返回回复内容
    │
    ▼
AIService 调用 MessageService.sendAIMessage()
    │
    ├─ 创建消息（messageType=AI, sender=null）
    │
    ├─ 存入数据库
    │
    └─ WebSocket 广播给群内在线成员
         │
         ▼
    前端收到 → 显示 AI 消息气泡（带机器人头像、紫色背景）
              → 消息下方显示"引用"按钮
                    │
                    用户点击引用 → 进入引用回复模式
                    → 发送的消息自动带 replyToId
                    → 后端检测到"回复的是 AI 消息" → 再次触发 AI
                    → 实现多轮对话 ♻️
```

### 5.7 多轮对话的实现原理

A宝支持两种 AI 对话模式：

**模式一：@AI 新话题**
```
用户：@AI 推荐一部电影
AI：推荐《肖申克的救赎》，经典中的经典！
```

**模式二：引用追问（多轮对话）**
```
用户：@AI 推荐一部电影
AI：推荐《肖申克的救赎》，经典中的经典！
用户：[引用AI的回复] 有没有轻松一点的？     ← replyToId 指向 AI 那条消息
AI：那试试《土拨鼠之日》，喜剧 + 哲理。     ← 因为 replyTo 是 AI 消息，触发回复
用户：[引用AI的回复] 是讲什么的？
AI：一个气象播报员发现自己每天都在重复同一天...
```

**关键细节**：引用追问时，AI 不只看被引用的那条消息，而是看最近 30 分钟的完整上下文。所以它能理解对话脉络，不会"失忆"。

### 5.8 AI 服务的关键人员

| 角色 | 文件 | 职责 |
|------|------|------|
| 顾问主管 | `AIService.java` | 判断是否触发 AI、构建上下文、调用 API、处理回复 |
| 事件监听员 | `MessageEventListener.java` | 监听"新消息"事件，转交给 AI 主管判断 |
| 异步配置 | `AsyncConfig.java` | 配置独立线程池，确保 AI 处理不阻塞主流程 |

---

## 第六章 前端门面：用户看到的一切

### 6.1 这个部门做什么

前端是公司的**大厅和展厅**——用户看到的所有界面、点击的所有按钮、感受到的所有交互，都是前端负责的。

### 6.2 页面导航地图

```
App 启动
    │
    ▼
┌──────────────┐
│  Splash 页面  │ ← 1.5 秒启动屏，自动检查登录状态
└──────┬───────┘
       │
  ┌────┴─────────────────┐
  │                      │
  ▼                      ▼
已登录                  未登录
  │                      │
  ▼                      ▼
┌──────────────┐  ┌──────────────┐
│ 群聊列表页面  │  │  登录页面     │◀──┐
│              │  └──────┬───────┘   │
│ ┌──────────┐ │         │           │
│ │ 群聊卡片  │─┼──┐      ▼           │
│ │ 群聊卡片  │ │  │  ┌──────────┐   │
│ │ 群聊卡片  │ │  │  │ 注册页面  │   │
│ └──────────┘ │  │  └──────┬───┘   │
│              │  │         ▼        │
│  [+] 按钮 ──┼──┼──┐ ┌──────────┐  │
└──────────────┘  │  │ │邮箱验证页│  │
                  │  │ └──────────┘  │
                  │  │               │
                  │  ▼               │
                  │ ┌──────────────┐ │
                  │ │ 创建群聊     │ │
                  │ │ 加入群聊     │ │
                  │ └──────────────┘ │
                  │                  │
                  ▼                  │
            ┌──────────────┐        │
            │  聊天页面     │        │
            │  （最复杂）   │        │
            │              │        │
            │ - 消息列表    │        │
            │ - 输入框      │        │
            │ - @AI 按钮   │        │
            │ - 引用回复栏  │        │
            │ - 日期分隔线  │        │
            └──────┬───────┘        │
                   │                │
                   ▼                │
            Token 过期，自动退出 ────┘
```

### 6.3 状态管理：前端的"中枢神经"

Flutter 用 **Provider** 做状态管理。你可以把它想象成一个"广播站"——数据变了，所有订阅了这个频道的页面都会自动刷新。

```
┌────────────────────────────────────────────────┐
│                 AuthProvider                    │
│            （身份广播站）                         │
│                                                │
│  广播内容：                                     │
│  - 当前用户信息（昵称、邮箱、头像）               │
│  - 登录状态（加载中/已登录/未登录/出错）          │
│  - 错误信息（"密码错误"、"会话过期"）             │
│                                                │
│  收听者：Splash 页面、登录页面、主页顶部          │
└────────────────────────────────────────────────┘

┌────────────────────────────────────────────────┐
│                 ChatProvider                    │
│            （聊天广播站）                         │
│                                                │
│  广播内容：                                     │
│  - 群聊列表（名称、最后消息、时间、未读数）        │
│  - 当前群聊的消息列表                            │
│  - 正在引用回复的消息（如果有）                   │
│  - 加载状态和错误信息                            │
│                                                │
│  收听者：群聊列表页、聊天页、创建/加入群聊页       │
└────────────────────────────────────────────────┘
```

**决策者视角**：Provider 模式的好处是"数据单一来源"。不管哪个页面改了数据（发消息、收消息、退出群聊），所有页面都能同步更新。坏处是两个 Provider 已经承载了所有状态，如果功能继续增多，可能需要拆分。

### 6.4 网络层的三重防护

前端的网络层有三道防线，确保用户体验尽可能流畅：

```
第一道：Dio 拦截器（自动带 Token）
─────────────────────────────────
每个 HTTP 请求自动从加密存储读取 Token，塞进 Header。
用户不需要关心认证的事。

第二道：401 自动重试（静默刷新 Token）
─────────────────────────────────────
如果后端说"Token 过期了"：
  → 自动用 Refresh Token 换一个新的
  → 用新 Token 重发刚才的请求
  → 用户毫无感知
  → 有 _retried 标记防止无限重试

第三道：会话过期全局处理
───────────────────────
如果 Refresh Token 也过期了（7 天没打开 App）：
  → TokenManager 发出"会话过期"信号
  → AuthProvider 收到信号，改状态为"未登录"
  → main.dart 的监听器检测到状态变化
  → 自动跳转登录页，弹窗提示"请重新登录"
```

### 6.5 聊天页面：最复杂的一个页面

聊天页面是整个 App 最复杂的地方，值得单独说说它的构成：

```
┌──────────────────────────────────────────┐
│  ← 返回    群聊名称    ⚙️ 设置            │  ← 顶部导航栏
├──────────────────────────────────────────┤
│                                          │
│        ── 2月7日 ──                       │  ← 日期分隔线
│                                          │
│  🧑 张三                    14:30        │
│  ┌─────────────────────────────┐        │
│  │ @AI 今天天气怎么样           │        │  ← 用户消息（灰色气泡）
│  └─────────────────────────────┘        │
│                                          │
│  🤖 AI                      14:30        │
│  ┌─────────────────────────────┐        │
│  │ 今天北京晴，最高温 15°C      │        │  ← AI 消息（紫色气泡）
│  │                     [引用]   │        │  ← 引用按钮（点击后追问）
│  └─────────────────────────────┘        │
│                                          │
├──────────────────────────────────────────┤
│  ↩️ 回复 AI: 今天北京晴...        ✕      │  ← 引用回复栏（可关闭）
├──────────────────────────────────────────┤
│  [@] │  输入消息...              [发送]   │  ← 输入栏（[@] 是快捷 @AI 按钮）
└──────────────────────────────────────────┘
```

**交互细节**：
- 消息列表是**倒序渲染**的（最新消息在底部），新消息自动滚到底
- 点击 AI 消息的"引用"按钮 → 输入框上方出现引用预览栏 → 发送时自动带上 replyToId
- 点击 `[@]` 按钮 → 在输入框光标处插入 `@AI `（末尾有空格，方便继续打字）
- 日期分隔线按天显示："今天"、"昨天"、"周一"、"2月5日"

### 6.6 前端关键文件索引

| 层级 | 文件 | 一句话职责 |
|------|------|-----------|
| 入口 | `main.dart` | 应用启动、全局 Provider 注入、会话过期监听 |
| 模型 | `models/user.dart` | 用户数据结构，昵称回退逻辑 |
| 模型 | `models/group.dart` | 群聊数据结构，copyWith 更新 |
| 模型 | `models/message.dart` | 消息数据结构，区分 user/ai/system |
| 状态 | `providers/auth_provider.dart` | 管理登录状态和用户信息 |
| 状态 | `providers/chat_provider.dart` | 管理群聊列表、消息、WebSocket |
| 网络 | `services/api_service.dart` | HTTP 请求封装，自动 Token、自动重试 |
| 网络 | `services/websocket_service.dart` | WebSocket 连接、心跳、重连 |
| 网络 | `services/token_manager.dart` | Token 刷新、过期检测、会话过期信号 |
| 页面 | `screens/chat/chat_screen.dart` | 聊天页面（最复杂的页面） |
| 页面 | `screens/chat/chat_list_screen.dart` | 群聊列表页面 |

---

## 第七章 技术决策备忘录

> 每个技术决策背后都有"为什么这么做"和"为什么不那么做"。作为决策者，这些是你在技术讨论中最有价值的知识。

### 7.1 架构级决策

| 决策 | 选择 | 为什么 | 否决的替代方案 |
|------|------|--------|--------------|
| 前后端分离 | Flutter + Spring Boot | 前端跨平台（一套代码三端），后端企业级框架 | React Native + Node.js（JS 全栈，但性能不如 Flutter） |
| 数据库 | PostgreSQL | 最可靠的开源关系型数据库，JSON 支持好 | MongoDB（文档型，群聊关系建模不自然） |
| 缓存 | Caffeine 本地缓存 | MVP 单实例，本地缓存延迟纳秒级 | Redis（多实例时需要，但目前是杀鸡用牛刀） |
| 实时通信 | 原生 WebSocket | 比 STOMP 更灵活，协议自定义 | STOMP（Spring 内置但限制多）、Socket.IO（需额外依赖） |
| AI 模型 | DeepSeek Chat | 国产模型，性价比高，API 兼容 OpenAI 格式 | OpenAI GPT（贵）、文心一言（API 风格不同） |

### 7.2 安全级决策

| 决策 | 选择 | 为什么 | 风险 |
|------|------|--------|------|
| 认证方式 | JWT 双 Token | 无状态、可扩展、前端存储方便 | Token 泄露无法即时撤销（需等过期） |
| 密码加密 | BCrypt 10轮 | Spring Security 内置，社区成熟 | Argon2 更安全但需额外依赖 |
| WebSocket 认证 | Query 参数传 Token | 浏览器 WebSocket API 不支持自定义 Header | Token 可能出现在服务器日志中 |
| 异常处理 | 全局拦截+消息关键字映射 | 避免自定义异常类泛滥 | 关键字匹配不够精确（"不存在"可能有歧义） |

### 7.3 AI 服务级决策

| 决策 | 选择 | 为什么 | 权衡 |
|------|------|--------|------|
| 触发方式 | @AI + 引用回复 | 明确的用户意图，不会误触发 | 不支持隐式触发（如"帮我查一下"） |
| 上下文窗口 | 30 分钟 + 50 条上限 | 活跃对话窗口，控制 Token 消耗 | 冷群重新提问需要重复上下文 |
| 异步处理 | Spring @Async | 简单有效，不阻塞主流程 | 无持久化队列，重启会丢失进行中的 AI 请求 |
| 消息格式 | "昵称: 内容" | OpenAI name 字段不支持中文 | AI 可能混淆昵称和消息内容 |

---

## 第八章 风险地图：哪里可能出问题

### 8.1 当前已知风险

```
风险等级：🔴 高  🟡 中  🟢 低

🟡 WebSocket 单实例瓶颈
   现状：所有 WebSocket 连接在一个 JVM 内存中管理
   影响：无法水平扩展到多台服务器
   对策：用户量突破 1000 前不用担心。之后需要引入 Redis Pub/Sub

🟡 AI API 无限流保护
   现状：DeepSeek API 调用没有频率限制
   影响：恶意用户可以疯狂 @AI，耗光 API 额度
   对策：应添加每用户每分钟调用上限（建议 10 次/分钟）

🟢 邮件服务依赖第三方
   现状：Resend API 如果挂了，用户收不到验证邮件
   影响：新用户无法完成邮箱验证（但注册不受影响）
   对策：已做容错设计，开发环境可手动验证

🟢 消息历史无分页
   现状：前端只加载最近 50 条消息
   影响：用户看不到更早的聊天记录
   对策：Phase 2 实现上拉加载更多

🔴 AI 请求无持久化
   现状：@Async 在内存线程池中运行
   影响：如果服务器重启，正在处理的 AI 请求会丢失
   对策：短期可接受（AI 请求 2-5 秒完成），长期需要消息队列
```

### 8.2 已踩过的坑（避免重蹈覆辙）

| 坑 | 根因 | 教训 |
|----|------|------|
| AI 成员导致 NPE | `GroupMember.user` 为 null | 所有涉及 user 的代码都要检查 null |
| JPA 懒加载异常 | 查询没有 JOIN FETCH 关联表 | 需要跨表数据时，在 SQL 中显式 FETCH |
| 后端 403 而非正确错误码 | 异常转发到 /error 被 Security 拦截 | 全局异常处理器在 Security 之前拦截 |
| 前端 fromJson 崩溃 | 后端返回了 null 的日期字段 | 所有 fromJson 解析都要做 null 兜底 |
| Flutter Web 被代理拦截 | 系统代理 + 环境变量双重影响 | 开发时必须 unset 所有代理变量 |

### 8.3 如果要扩展，优先做什么？

```
优先级排序（投入产出比从高到低）：

[1] AI 调用限流                       投入：小  影响：防止 API 费用失控
[2] 消息历史分页                       投入：小  影响：用户体验大幅提升
[3] Redis 缓存层                      投入：中  影响：为多实例部署铺路
[4] WebSocket 多实例支持               投入：大  影响：突破单机连接数上限
[5] 消息队列（AI 请求持久化）           投入：大  影响：AI 请求不丢失
```

---

## 附录 A：快速参考 - 文件在哪里

### 后端（Spring Boot）

```
server/src/main/java/com/abao/
├── AbaoApplication.java          # 应用入口
├── config/
│   ├── SecurityConfig.java       # 安全规则（哪些 API 需要登录）
│   ├── WebSocketConfig.java      # WebSocket 路由注册
│   ├── AsyncConfig.java          # 异步线程池配置
│   └── CacheConfig.java          # Caffeine 缓存配置
├── controller/
│   ├── AuthController.java       # 登录/注册/刷新 API
│   ├── GroupController.java      # 群聊增删查 API
│   └── MessageController.java    # 消息发送/查询 API
├── service/
│   ├── AuthService.java          # 认证业务逻辑
│   ├── GroupService.java         # 群聊业务逻辑
│   ├── MessageService.java       # 消息业务逻辑 + WebSocket 广播
│   ├── AIService.java            # ★ AI 核心逻辑（触发/上下文/调用）
│   └── EmailService.java         # 邮件验证
├── entity/
│   ├── User.java                 # 用户表
│   ├── Group.java                # 群聊表
│   ├── GroupMember.java          # 成员关系表
│   ├── Message.java              # 消息表
│   └── RefreshToken.java         # 刷新令牌表
├── security/
│   ├── JwtTokenProvider.java     # JWT 生成和验证
│   └── JwtAuthenticationFilter.java  # 请求拦截验证
├── websocket/
│   ├── WebSocketHandler.java     # WebSocket 消息路由
│   ├── WebSocketSessionManager.java  # 在线用户管理
│   └── JwtHandshakeInterceptor.java  # WebSocket 连接认证
├── event/
│   ├── MessageSentEvent.java     # 消息发送事件
│   └── MessageEventListener.java # 事件监听→触发 AI
└── exception/
    └── GlobalExceptionHandler.java   # 全局异常处理
```

### 前端（Flutter）

```
app/lib/
├── main.dart                     # 应用入口 + Provider 注入
├── models/
│   ├── user.dart                 # 用户数据模型
│   ├── group.dart                # 群聊数据模型
│   └── message.dart              # 消息数据模型
├── providers/
│   ├── auth_provider.dart        # 认证状态管理
│   └── chat_provider.dart        # 聊天状态管理
├── services/
│   ├── api_service.dart          # HTTP 封装（自动 Token、自动重试）
│   ├── websocket_service.dart    # WebSocket（心跳、重连）
│   ├── auth_service.dart         # 认证 API 调用
│   └── token_manager.dart        # Token 生命周期管理
├── screens/
│   ├── auth/
│   │   ├── splash_screen.dart    # 启动页
│   │   ├── login_screen.dart     # 登录页
│   │   ├── register_screen.dart  # 注册页
│   │   └── verify_email_screen.dart  # 邮箱验证页
│   ├── chat/
│   │   ├── chat_list_screen.dart # 群聊列表
│   │   ├── chat_screen.dart      # ★ 聊天页面（最复杂）
│   │   ├── create_group_screen.dart  # 创建群聊
│   │   └── join_group_screen.dart    # 加入群聊
│   └── settings/
│       └── settings_screen.dart  # 设置页
└── utils/
    └── auto_login_utils.dart     # E2E 测试用自动登录
```

---

## 附录 B：问对问题清单

> 当你参与技术讨论时，以下问题能帮你迅速切中要害。

### 遇到 Bug 时问

1. "这个问题发生在前端还是后端？" → 先定位是哪一半的责任
2. "数据库里的数据对不对？" → 用 `docker exec` 直接查数据库
3. "后端日志里有什么？" → `docker logs abao-server`
4. "是 WebSocket 断了还是 HTTP 请求失败了？" → 两条管道要分开排查

### 讨论新功能时问

1. "这个功能影响哪几个模块？" → 用附录 A 的目录结构判断改动范围
2. "需要改数据库表结构吗？" → 如果需要，就需要数据库迁移脚本
3. "对 AI 服务有影响吗？" → 上下文构建逻辑是否需要调整
4. "WebSocket 需要新增消息类型吗？" → 前后端协议要同步更新

### 评估技术方案时问

1. "这个方案在 1000 用户时还能跑吗？" → 关注 WebSocket 连接数和数据库查询性能
2. "如果第三方服务挂了会怎样？" → 容错设计（如邮件服务的降级处理）
3. "这个改动可以回滚吗？" → 数据库 schema 变更尤其需要注意
4. "有没有更简单的做法？" → MVP 阶段，简单即正义

---

*本文档基于 A宝项目代码实际调研编写，所有技术细节均来自源代码分析，未做任何编造。*
